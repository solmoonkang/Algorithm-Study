## 시간 복잡도란?

---

시간 복잡도란 입력 값과 연산 수행 시간의 상관관계를 나타내는 척도를 의미한다.

이러한 시간 복잡도는 점근적 표기법 3가지로 시간 복잡도를 나타낼 수 있다.

- 최상의 경우: 오메가 표기법
- 평균의 경우: 세타 표기법
- 최악의 경우: 빅오 표기법

시간 복잡도의 평균을 구할 때 세타 표기법을 사용한다 생각할 수 있는데, 평가하기 까다롭다는 판단이 있다.

따라서 평균은 최상과 최악의 평균값으로 시간 복잡도는 최악을 기준으로 “빅오 표기법”으로 판단한다.

빅오 표기법은 불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적으로 사용된다.

Big-O로 측정되는 복잡성에는 시간 복잡도와 공간 복잡도가 있다.

---

- 시간 복잡도는 입력된 N의 크기에 따라 실행되는 조작의 수를 나타낸다.
- 공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리의 양을 의미한다.

시간 복잡도는 다음과 같이 빠른 순서대로 나열할 수 있다.

<aside>
📌 O(1) < O(logN) < O(N) < O(NlogN) < O(N^2)

</aside>

---

- O(1) - 상수 시간: 문제를 해결하는데 오직 한 단계만 처리한다.
- O(logN) - 로그 시간: 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.
- O(N) - 직선적 시간: 문제를 해결하기 위한 단계의 수와 입력값 N이 1 : 1 관계를 갖는다.
- O(NlogN) - 선형 로그형: 문제를 해결하기 위한 단계의 수가 N * (log2N)번만큼의 수행시간을 갖는다.
- O(N^2) - 2차 시간: 문제를 해결하기 위한 단계의 수는 입력값 N의 제곱이다.

## 시간 복잡도 계산 과정

---

코딩 테스트 문제를 풀 때, 시간 복잡도를 계산하는 것은 알고리즘의 효율성을 평가하는 중요한 단계이다.

시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 추정하여, 입력 크기가 커질 때 알고리즘의 실행 시간이 어떻게 증가하는지를 나타낸다.

1. 알고리즘의 기본 연산을 찾는다.
2. 기본 연산이 실행되는 횟수를 입력 크기에 대한 함수로 나타낸다.
3. 입력 크기에 대한 함수를 단순화한다.
4. 단순화된 함수에서 가장 높은 차수의 항만을 남기고, 계수를 제외한다.
5. 최종적으로 남은 항이 시간 복잡도이다.

코딩 테스트에서는 대체로 시간제한이 1초 이하인 경우가 많아, 이를 고려하여 설계하고 계산하는 것이 중요하다.

따라서 1억 번의 실행 횟수를 1초로 계산하는 것은 유용하다.

이를 기준으로 시간 복잡도를 계산하면 어느 정도 수행 시간을 예측할 수 있다.

### O(1) 시간 복잡도

---

- 입력값의 크기에 상관없이 일정한 실행 시간을 가지므로 가장 빠른 시간 복잡도이다.
- 배열에서 **특정 인덱스**에 접근하는 경우이다.

### O(logN) 시간 복잡도

---

- 입력값이 2배씩 증가할 때마다 실행 시간이 1배씩 증가한다.
- **이진 탐색**과 같은 알고리즘의 경우이다.

### O(N) 시간 복잡도

---

- 입력값의 크기에 비례하여 실행 시간이 증가한다.
- 배열의 **모든 요소를 순회**하면서 처리하는 경우이다.

### O(NlogN) 시간 복잡도

---

- 입력값이 커질수록 실행 시간이 증가하지만, O(N^2)보다는 빠른 실행 시간을 갖는다.
- 대부분의 **퀵 정렬**과 **병합 정렬**과 같은 정렬 알고리즘의 경우이다.

### O(N^2) 시간 복잡도

---

- 입력값의 제곱에 비례하여 실행 시간이 증가한다.
- **이중 반복문**을 사용하여 이차원 배열을 처리하는 경우이다.